\section{Πλήρης κάλυψη χώρου}
\label{section:coverage_impl}

Το πρόβλημα της κάλυψης χώρου έχει δύο βασικές εκδοχές: με χάρτη και χωρίς χάρτη. Στην εργασία αυτή, ο χάρτης είναι διαθέσιμος σε μορφή OctoMap και σκοπός είναι η πλοήγηση του ρομπότ μέχρι να καλυφθεί όλος ο χάρτης, ή τουλάχιστον όλα τα σημεία ενδιαφέροντος σε αυτόν. Υπάρχουν διάφοροι τρόποι για την επίλυση αυτού του προβλήματος, είτε οι αναλυτικοί, αλλά υπολογιστικά αργοί αλγόριθμοι, είτε οι ευριστικοί που με την χρήση ορισμένων πρακτικών κανόνων επιταχύνουν την αναζήτηση.

Βασική ιδέα είναι όλα τα αντικείμενα του χώρου να βρεθούν κάποια στιγμή στο οπτικό πεδίο ενός αισθητήρα που βρίσκεται πάνω στο ρομπότ. Στη συγκεκριμένη περίπτωση, πρόκειται για έναν αναγνώστη RFID με τα παρακάτω παραμετροποιήσιμα χαρακτηριστικά:
\begin{itemize}
    \item {Εμβέλεια}
    \item {Οριζόντιο και κάθετο πεδίο όρασης}
    \item {Τη μορφή του πεδίου κάλυψης (ορθογώνιο/κυκλικό)}
    \item {Το διάνυσμα που δίνει την κατεύθυνση του αναγνώστη}
\end{itemize}

Για να υπολογίσουμε τα σημεία στα οποία πρέπει να βρεθεί το ρομπότ, ώστε να πετύχει την πλήρη κάλυψη του χώρου, υποδειγματοληπτούμε τον χώρο με κάποιο σταθερό βήμα ως προς $x$ και $y$ και διαφορετικό βήμα ως προς $z$, φροντίζοντας πάντα να διατηρούνται οι αποστάσεις ασφαλείας του drone από οποιοδήποτε στατικό εμπόδιο στο περιβάλλον. Το βήμα δειγματοληψίας ως προς τον $z$ άξονα υπολογίζεται με βάση τη γωνία του κάθετου οπτικού πεδίου του αισθητήρα, με σκοπό κάθε σημείο του χώρου να βρεθεί εντός του πεδίου οράσεως τουλάχιστον δύο φορές. Συνεπώς, χρησιμοποιώντας τριγωνομετρία, υπολογίζεται με τον παρακάτω τύπο:
\begin{equation}
    z_{step} = range \cdot tan(fov_{vertical} / 2)
\end{equation}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.8\textwidth]{./images/chapter5/z_step.png}
    \caption{Μετάβαση του drone από το ύψος Α στο ύψος Β}
    \label{fig:z_step}
\end{figure} 

Πιο συγκεκριμένα, στο \autoref{fig:z_step} το σημείο $P$ βρίσκεται εντός του οπτικού πεδίου του drone, όταν αυτό είναι στο ύψος $A$ και όταν είναι στο ύψος $B = A + range \cdot tan(fov_{vertical}/2)$. 

Στη συνέχεια, για κάθε ένα σημείο που προκύπτει από την δειγματοληψία ελέγχουμε εάν η θέση αυτή είναι ασφαλής για το ρομπότ. Οι έλεγχοι που πραγματοποιούνται είναι: αν η θέση αυτή ανήκει σε κατειλημμένο κόμβο του χάρτη μορφής OctoMap και εάν υπάρχουν εμπόδια σε απόσταση μικρότερη από την επιτρεπόμενη απόσταση ασφαλείας που έχει οριστεί. Με χρήση του προβαλλόμενου χάρτη σε δύο διαστάσεις, μπορούμε επιπλέον να ελέγξουμε αν το κελί της θέσης που μας ενδιαφέρει βρίσκεται σε χώρο που υπάρχει εμπόδιο και δεν έχει αναγνωριστεί με κανέναν από τους προηγούμενους τρόπους.

Εφόσον αυτοί οι έλεγχοι καταλήξουν στο συμπέρασμα ότι η θέση είναι ασφαλής για το drone, υπολογίζουμε τον προσανατολισμό ο οποίος προσδίδει καλύτερη ορατότητα του αντικειμένου. Για το λόγο αυτό, ελέγχουμε διαδοχικά διαφορετικές γωνίες και υπολογίζουμε το ποσοστό κάλυψης από την καθεμία. Ο αλγόριθμος που περιγράφει τον τρόπο υπολογισμού του ποσοστού κάλυψης για μία συγκεκριμένη κατεύθυνση φαίνεται στον \autoref{alg:calculate_coverage}. Αρχικά, με χρήση της συνάρτησης $castRay(\cdot)$ της βιβλιοθήκης OctoMap, υπολογίζουμε την θέση του σημείου που βρίσκεται στο κέντρο του οπτικού πεδίου του αισθητήρα. Στη συνέχεια, η θέση αυτή και η κατεύθυνση του αισθητήρα, δίνονται ως ορίσματα στην συνάρτηση υπολογισμού. Εκεί υπολογίζοντας το γινόμενο του κάθετου διανύσματος της επιφάνειας και του διανύσματος της κατεύθυνσης, προκύπτει μία μετρική αξιολόγησης της γωνίας αυτής. 

Για τον υπολογισμό του κάθετου διανύσματος της επιφάνειας, χρησιμοποιείται η συνάρτηση $getNormals(\cdot)$ που παρέχει επίσης η βιβλιοθήκη OctoMap. Η συνάρτηση αυτή επιστρέφει τα κάθετα διανύσματα των κορυφών των τριγώνων τα οποία περιέχουν το σημείο το οποίο εξετάζεται. Είναι πιθανό κάποιο σημείο να μην βρίσκεται σε κάποια κορυφή και να βρίσκεται στο εσωτερικό ενός τριγώνου. Στην περίπτωση αυτή, αναζητούμε το κάθετο διάνυσμα γειτονικών κόμβων σε συγκεκριμένη ακτίνα, καθώς θεωρούμε ότι βρίσκονται στην ίδια επιφάνεια και συνεπώς το κάθετο διάνυσμα θα ταυτίζεται. Τέλος, βρίσκουμε τον μέσο όρο των διανυσμάτων αυτών και το αποτέλεσμα θα χρησιμοποιηθεί για τον υπολογισμό της μετρικής.

\begin{algorithm}[!ht]
 \caption{Αλγόριθμος υπολογισμού καλύτερης γωνίας θέασης}
 \label{alg:calculate_coverage}
 \begin{algorithmic}[1]
    \Function{calculateCoverage}{point\_on\_wall, direction}
        \State $coverage \gets 0$
        \State $normals \gets point\_on\_wall.getNormals()$
        \While {$normals.size() = 0$}
            \State $normals \gets point\_on\_wall.getNormals()$ \Comment{Calculate normals in a larger bounding box around point\_on\_wall}
        \EndWhile
        \State $mean \gets normals.mean()$
        \State $coverage \gets direction \cdot mean$
        \State \Return $coverage$
    \EndFunction 
    \end{algorithmic}
\end{algorithm}

Μετά την εκτέλεση της διαδικασίας αυτής, αποθηκεύεται για κάθε θέση $(x, y, z)$ η τιμή του $yaw$ που προσφέρει την καλύτερη οπτική γωνία. Οι τιμές των roll και pitch θεωρούνται μηδενικές, καθώς είναι επιθυμητοί οι αργοί ελιγμοί, ώστε να επιτευχθεί ακρίβεια.

Στη συνέχεια, εφαρμόζεται μια περαιτέρω επεξεργασία σε αυτά, ώστε να αποκλειστούν σημεία τα οποία δεν είναι ορατά και επομένως δεν είναι προσβάσιμα από κανένα άλλο σημείο του χώρου. Για το λόγο αυτό, σε κάθε ένα από τα σημεία που έχουν προκύψει εφαρμόζεται ο αλγόριθμος πλησιέστερου γείτονα (\emph{Nearest Neighbor Algorithm}), ώστε να ελεγχθούν γειτονικά σημεία του καθενός και να αποκλειστούν αυτά τα οποία δεν είναι προσβάσιμα με άμεσο τρόπο. Πιο συγκεκριμένα, για κάθε σημείο ελέγχουμε να βρούμε γειτονικά σημεία που απέχουν απόσταση μικρότερη από το 0.75 του εύρους του αισθητήρα RFID και δεν έχουν θεωρηθεί ήδη ως προσβάσιμα από κάποιο άλλο σημείο. Ο έλεγχος της ορατότητας για κάθε γείτονα πραγματοποιείται με χρήση της συνάρτησης $computeRayKeys(\cdot)$ της βιβλιοθήκης OctoMap. Η διαδικασία αυτή εφαρμόζεται αναδρομικά για κάθε σημείο, μέχρι να μην υπάρχει άλλο διαθέσιμο σημείο. 

Για την οπτικοποίηση της επιφάνειας που καλύπτεται από τον αισθητήρα, δημιουργούμε έναν νέο χάρτη μορφής OctoMap, στον οποίο προστίθενται όλα τα σημεία που έχουν βρεθεί στον οπτικό πεδίο του. Έχοντας πλέον όλες τις θέσεις στις οποίες πρέπει να βρεθεί το ρομπότ με την σωστή κατεύθυνση, μπορούμε να υπολογίσουμε μια εκτίμηση του ποσοστού κάλυψης του χώρου σε \si{\cubic\metre}. Η διαδικασία αυτή περιγράφεται στον \autoref{alg:calculate_volume}.

\newcommand{\pluseq}{\mathrel{+}=}

\begin{algorithm}[!ht]
 \caption{Υπολογισμός όγκου ενός OctoMap}
 \label{alg:calculate_volume}
    \begin{algorithmic}[1]
        \State {$volume \gets 0$}
        \For{i = 1 to N}
            \If{ $node(i).z() > max\_height$ OR $node(i).z() < min\_height$}
                \State $continue$
            \EndIf
            \If{ $node(i)$ is Occupied}
                \State {$volume \pluseq node(i).size * node(i).size * node(i).size$}
            \EndIf
        \EndFor
        \State \Return $volume$
    \end{algorithmic}
\end{algorithm}

\begin{equation*}
    coverage (\%) = 100 * \frac{covered\_map_{volume}}{initial\_map_{volume}} 
\end{equation*}

Όπως φαίνεται στην γραμμή 3 του αλγορίθμου, περιορίζουμε τον χώρο σε ένα ελάχιστο και μέγιστο ύψος. Όσα σημεία βρίσκονται εκτός των ορίων αυτών δεν λαμβάνονται υπόψη στον υπολογισμό του όγκου. Ο λόγος που συμβαίνει αυτό είναι ο αποκλεισμός σημείων του χώρου, όπως το δάπεδο, που δεν παρουσιάζουν κανένα ενδιαφέρον για κάλυψη, αλλά και η εξάλειψη του θορύβου του χάρτη σε υψηλά σημεία. Επίσης, η ύπαρξη θορύβου στην αναπαράσταση του περιβάλλοντος δημιουργεί προβλήματα στην ακριβή αξιολόγηση της κάλυψης του χώρου. Συγκεκριμένα, υπάρχουν περιπτώσεις όπου δημιουργούνται σημεία τα οποία δεν είναι άμεσα ορατά από το ρομπότ και συνεπώς δεν θα έπρεπε να συνυπολογίζονται στον συνολικό όγκο. Αυτό συμβαίνει λόγω σφάλματος κατά την χαρτογράφηση του χώρου, όπου οι τοίχοι του περιβάλλοντος μπορούν να πάρουν τη μορφή που φαίνεται στο \autoref{fig:octomap_noise}.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.50\textwidth]{./images/chapter5/octomap_noise.png}
    \caption{Σφάλμα του χάρτη στην αναπαράσταση επιφανειών}
    \label{fig:octomap_noise}
\end{figure}

Δηλαδή κάποια σημεία στις επιφάνειες αποτελούνται εσφαλμένα από δύο διαχοχικούς κόμβους και δεν προσφέρουν κάποια χρήσιμη πληροφορία σχετική με το χώρο. Για το λόγο αυτό, εφαρμόζουμε μια επιπλέον επεξεργασία του χάρτη προτού υπολογιστεί ο όγκος του. Η διαδικασία αυτή φαίνεται στο \autoref{fig:octomap_proprocess}, κατά την οποία αποκλείουμε τους εξωτερικούς κόμβους από τον υπολογισμό του όγκου, καθώς αρκεί η κάλυψη των άμεσα ορατών από τον αισθητήρα.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.35\textwidth]{./images/chapter5/octomap_proprocess.png}
    \caption{Εύρεση σημείων που δεν λαμβάνονται υπόψη στον υπολογισμό του όγκου ενός OctoMap}
    \label{fig:octomap_proprocess}
\end{figure}

Με τα βήματα που περιγράφτηκαν έως τώρα γίνεται ένας τυχαίος υπολογισμός των σημείων που προσφέρουν την καλύτερη δυνατή κάλυψη του χώρου. Στη συνέχεια, πρέπει να βρεθεί η σειρά με την οποία το drone πρέπει να προσπελάσει αυτά τα σημεία, ώστε η κάλυψη του χώρου να γίνεται με όσο το δυνατόν πιο βέλτιστο τρόπο, είτε όσον αφορά το χρόνο κάλυψης, είτε την απόσταση που θα διανύσει. 

Για την επίλυση του προβλήματος αυτού, απαιτείται να το προσεγγίσουμε ως πρόβλημα του περιοδεύοντος πωλητή (\emph{Travelling Salesman Problem}). Εν συντομία, πρόκειται για την περίπτωση όπου ένας πωλητής πρέπει να επισκεφτεί $n$ διαφορετικές πόλεις και πρέπει να υπολογιστεί η συντομότερη και χαμηλότερου κόστους διαδρομή, ώστε να επισκεφτεί κάθε πόλη μόνο μία φορά. Πρόκειται για ένα NP-hard πρόβλημα, του οποίου όσο αυξάνεται ο αριθμός των πόλεων, τόσο αυξάνεται και η πολυπλοκότητά του. 

Αρχικά, επιχειρήθηκε η επίλυση του προβλήματος με τη χρήση του αλγορίθμου \emph{Hill climbing}. Όμως, το μεγάλο πλήθος των σημείων δεν επέτρεπε την εκτέλεση του αλγορίθμου σε λογικό χρόνο και η βελτίωση που υπήρχε ήταν πολύ μικρή. Όπως είναι λογικό, στην περίπτωση κάλυψης χώρου για μία βιομηχανική αποθήκη είναι σημαντική η πιθανότητα ο αριθμός των σημείων να είναι πολύ μεγάλος, με αποτέλεσμα να γίνεται αρκετά πολύπλοκη η επίλυση του προβλήματος με οποιονδήποτε τρόπο.

Για το λόγο αυτό, επεξεργαζόμαστε τα σημεία που έχουν προκύψει, ώστε να μειωθεί ο αριθμός τους και να λυθεί πιο εύκολα το πρόβλημα της ελαχιστοποίησης του κόστους της διαδρομής. Ως κόστος, θεωρούμε την απόσταση που θα διανύσει το drone για να επιτύχει την πλήρη κάλυψη.

Ένας τρόπος για να μειωθεί το πλήθος των σημείων είναι η μείωση των διαστάσεων αυτών. Τα σημεία έως τώρα είναι της μορφής $\kappa = (x, y, z, \theta)$. Το πλήθος αυτών θα μπορούσε να μειωθεί τόσες φορές, όσα είναι και τα διαφορετικά ύψη στα οποία θα πρέπει να βρεθεί το drone, κρατώντας μόνο την τετμημένη και τεταγμένη των σημείων. Ουσιαστικά, πρόκειται για μια προβολή των τρισδιάστατων σημείων στον δισδιάστατο χώρο. 

Πλέον, καθώς ο αριθμός των σημείων είναι αρκετά μικρότερος, μπορεί να εφαρμοστεί σε αυτά κάποιος αλγόριθμος για την εύρεση του βέλτιστου μονοπατιού. Δημιουργείται ένας μη κατευθυνόμενος γράφος με όλα τα σημεία $(x, y)$ που έχουν προκύψει, χρησιμοποιώντας την βιβλιοθήκη \emph{Boost Graph Library}\footnote{\href{https://www.boost.org/doc/libs/1\_66\_0/libs/graph/doc/index.html}{https://www.boost.org/doc/libs/1\_66\_0/libs/graph/doc/index.html}}. Για κάθε σημείο, προστίθεται ως γειτονικός κόμβος κάθε άλλο σημείο που απέχει απόσταση μικρότερη από το 0.75 του εύρους του αισθητήρα κάλυψης. Το βάρος μεταξύ των δύο κόμβων πρόκειται για την απόσταση αυτή.

Για την εύρεση του βέλτιστου μονοπατιού, χρησιμοποιούμε έναν συνδυασμό των αλγορίθμων Nearest Neighbor και Hill Climbing, ώστε να αξιοποιήσουμε γειτονικά σημεία και να προσπαθήσουμε να μειώσουμε τις αποστάσεις μεταξύ σημείων που βρίσκονται αρκετά μακριά με ευριστικό τρόπο. Για τον υπολογισμό της απόστασης μεταξύ των κόμβων στο γράφο, χρησιμοποιείται ο αλγόριθμος \emph{A*}. Πιο συγκεκριμένα, για κάθε ένα σημείο $(x, y)$ ελέγχουμε την απόσταση του από το επόμενο και το προηγούμενο του, καθώς ο τρόπος με τον οποίο δημιουργήθηκαν τα σημεία, επιτρέπει την ύπαρξη γειτονικών σημείων διαδοχικά στη δομή που αποθηκεύτηκαν. Επίσης, γνωρίζουμε την ελάχιστη απόσταση που μπορούν να έχουν δύο σημεία, η οποία είναι ίση με το βήμα δειγματοληψίας που χρησιμοποιήθηκε παραπάνω. Εάν κανένα από τα δύο γειτονικά δεν καλύπτουν τις απαιτήσεις απόστασης, επιχειρούμε να βρούμε το καλύτερο επόμενο σημείο επιλέγοντας έναν τυχαίο κόμβο και ελέγχοντας την απόσταση του και αν είναι άμεσα προσβάσιμος με εύκολο τρόπο (π.χ. ενώνονται με ευθεία γραμμή). Η αναζήτηση συνεχίζεται για πεπερασμένο αριθμό επαναλήψεων ή μέχρις ότου βρεθεί σημείο που να βρίσκεται σε ελάχιστη απόσταση. 

Η παραπάνω διαδικασία εκτελείται για συγκεκριμένο αριθμό επαναλήψεων, ώστε να βελτιωθεί όσο τον δυνατόν περισσότερο η λύση που προκύπτει. Συνολικά, η διαδικασία παρουσιάζεται στον \autoref{alg:calculate_optimal_path}.

\makeatletter
\newcommand{\HEADER}[1]{\State\underline{\textsc{#1}}}
    \newcommand{\ENDHEADER}{}
\makeatother
\newcommand{\STATEI}[1]{\State
    \begin{tabular}{@{}p{\dimexpr \textwidth-\labelwidth}@{}}%
        \hangindent \algorithmicindent
        \hangafter 1
        #1
    \end{tabular}
}

\begin{algorithm}[!ht]
 \caption{Αλγόριθμος εύρεσης βέλτιστου μονοπατιού}
 \label{alg:calculate_optimal_path}
 \begin{algorithmic}
    \Function{calculateOptimalPath}{points}
    \STATEI {Calculate initial total distance}
        \For {i in restarts}
            \STATEI {Starting from node 0}
            \While {there are nodes left}
                \HEADER{Check nearest neighbor}
                \STATEI {Check the node after and the node before}
                \If{at least one of them is visible and in a small distance}
                    \STATEI {Make this node the current node and skip Hill Climbing below}
                \EndIf
                \HEADER {Hill Climbing}
                \Do 
                     \STATEI {Find a random node and calculate its distance from current node}
                     \STATEI {Keep the node with the minimum distance}
                \doWhile{any distance found is larger than the minimum AND max number of iterations is not reached}
            \EndWhile
            \STATEI {Keep the order of points with the minimum total cost}
        \EndFor
    \EndFunction 
    \end{algorithmic}
\end{algorithm}

Εφόσον έχει υπολογιστεί ένα μονοπάτι που συνδέει όλα τα σημεία στον δισδιάστατο χώρο, η λύση μπορεί να μεταφερθεί ξανά στον τρισδιάστατο χώρο. Αυτό είναι δυνατόν να συμβεί με δύο τρόπους, με την οριζόντια ή κάθετη ένωση των σημείων. Στο \autoref{fig:revert} φαίνονται με πιο ξεκάθαρο τρόπο οι δύο αυτές μέθοδοι.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=1.0\textwidth]{./images/chapter5/slice_lift.png}
    \caption{Οριζόντια και κάθετη ένωση των σημείων για επαναδιάταξη στον τρισδιάστατο χώρο}
    \label{fig:revert}
\end{figure} 

Τέλος, εφαρμόζεται ένα τελευταίο στάδιο επεξεργασίας του μονοπατιού. Ελέγχονται διαδοχικά όλα τα σημεία και αφαιρούνται αυτά τα οποία βρίσκονται στο ενδιάμεσο άλλων σημείων στους άξονες $x$, $y$ και $z$ και απέχουν μεταξύ τους την δεδομένη απόσταση δειγματοληψίας. Με τον τρόπο αυτό, επιδιώκουμε να έχουμε όσο το δυνατόν λιγότερα σημεία-στόχους, ώστε να είναι πιο ομαλή και συνεχόμενη η πορεία του ρομπότ. Πιο συγκεκριμένα, όπως φαίνεται στο \autoref{fig:postprocesspath}, τα σημεία 2, 5 και 8 παραλείπονται, καθώς είναι λογικό ότι κατά την μετάβαση του ρομπότ από το 1 στο 3, και αντίστοιχα για τα υπόλοιπα σημεία, θα διασχίσει το ενδιάμεσο αυτών, χωρίς να χρειάζεται να το ορίσουμε.

\begin{figure}[!h]
    \centering
    \includegraphics[width=0.65\textwidth]{./images/chapter5/postprocesspath.png}
    \caption{Τελευταίο στάδιο επεξεργασίας μονοπατιού κάλυψης}
    \label{fig:postprocesspath}
\end{figure} 

Πλέον, το σύνολο των σημείων που πρέπει να διασχίσει το ρομπότ, ώστε να πετύχει την πλήρη κάλυψη του χώρου είναι διαθέσιμο. Για την πλοήγηση του χρησιμοποιείται η βιβλιοθήκη OMPL, όπως περιγράφεται στο \autoref{section:ompl} και ο αλγόριθμος \emph{RRT*} για την δημιουργία ασφαλών μονοπατιών μεταξύ των σημείων (\autoref{fig:path_planning}). Για τον έλεγχο του drone, χρησιμοποιείται ο PID ελεγκτής θέσης, όπως περιγράφεται στο \autoref{section:pid}. Για την εξασφάλιση πιο ομαλής κίνησης, δεχόμαστε ότι το drone δεν χρειάζεται να βρεθεί ακριβώς στην θέση που του υποδηλώνουμε, αλλά είναι επιτρεπτή μια σχετικά μικρή απόσταση ώστε να θεωρηθεί ότι ο στόχος επετεύχθη και να αποσταλεί ο επόμενος. Έχει δημιουργηθεί επίσης ένας ROS κόμβος ο οποίος κατά την πλοήγηση του drone στο χώρο δείχνει σε πραγματικό χρόνο την περιοχή που καλύπτει ο αισθητήρας RFID και το ποσοστό κάλυψης κάθε στιγμή (\autoref{fig:coverage}). Αφού καλυφθεί όλος ο χώρος, όπως φαίνεται στο \autoref{fig:whole_coverage}, το drone επιστρέφει στην αρχική του θέση.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.90\textwidth]{./images/chapter5/path_planning.png}
    \caption{Δημιουργία μονοπατιού στο χώρο με αποφυγή εμποδίων}
    \label{fig:path_planning}
\end{figure} 

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.90\textwidth]{./images/chapter5/coverage.png}
    \caption{Κάλυψη χώρου από το drone σε πραγματικό χρόνο}
    \label{fig:coverage}
\end{figure} 

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.90\textwidth]{./images/chapter5/whole_coverage.png}
    \caption{Ολοκληρωμένη κάλυψη χώρου από το drone}
    \label{fig:whole_coverage}
\end{figure} 