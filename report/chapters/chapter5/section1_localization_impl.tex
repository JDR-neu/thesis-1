\section{Εντοπισμός θέσης}
\label{section:localization_impl}

Όπως αναφέρθηκε στο \autoref{section:libpf}, η κύρια μέθοδος που χρησιμοποιήθηκε για τον εντοπισμό της θέσης είναι ο αλγόριθμος \emph{Φίλτρου Σωματιδίων} (Particle Filter, PF). 

Η βασική ιδέα του φίλτρου είναι η αναπαράσταση της εκ των υστέρων πεποίθησης με ένα σύνολο τυχαίων δειγμάτων κατανομής που έχουν ληφθεί από την συγκεκριμένη εκ των υστέρων κατανομή. Κάθε σωματίδιο είναι ένα συνεπτυγμένο στιγμιότυπο της κατάστασης σε κάποια χρονική στιγμή. Ο αλγόριθμος αυτός απαιτεί ως είσοδο το προηγούμενο σύνολο σωματιδίων, ένα μοντέλο μέτρησης και ένα μοντέλο κίνησης. Η κύρια πηγή πληροφορίας για το πρώτο είναι οι αποστάσεις που προκύπτουν από τον αισθητήρα laser, ενώ για το δεύτερο είναι ο υπολογισμός της κίνησης του drone.

Το σύστημα δίνει τη δυνατότητα για την επίλυση του προβλήματος τοπικού και καθολικού εντοπισμού θέσης. Στην πρώτη περίπτωση, τα σωματίδια του φίλτρου αρχικοποιούνται γύρω από την αρχική θέση χρησιμοποιώντας μία κανονική κατανομή με δεδομένη τιμή της τυπικής απόκλισης, η οποία παρέχεται ως παράμετρος. Στην περίπτωση του Global Localization, τα σωματίδια αρχικοποιούνται με μία κανονική κατανομή σε όλο τον χάρτη του περιβάλλοντος. Η αρχική θέση παρέχεται επίσης ως παράμετρος του συστήματος. Η αρχικοποίηση των σωματιδίων φαίνεται στο \autoref{fig:initialize_particles}.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.8\textwidth]{./images/chapter5/initialize_particles.png}
    \caption{Αρχικοποίηση σωματιδίων}
    \label{fig:initialize_particles}
\end{figure} 

Όσον αφορά το μοντέλο κίνησης του ρομπότ, σε αντίθεση με τα επίγεια οχήματα, τα οποία διαθέτουν αυτήν την πληροφορία μέσω αισθητήρων κίνησης (π.χ. κωδικοποιητές στους τροχούς), σε ένα drone αυτό δεν είναι εφικτό. Μία λύση θα ήταν η χρήση οπτικής οδομετρίας, μέσω της κάμερας που διαθέτει. Καθώς όμως η ανάπτυξη του συστήματος πραγματοποιείται σε περιβάλλον προσομοίωσης με ιδανικές επιφάνειες, δεν θα είχαμε τα επιθυμητά αποτελέσματα. Για το λόγο αυτό, συνδυάζουμε την πληροφορία που προκύπτει από το IMU, τον αισθητήρα ύψους και την ταχύτητα που του παρέχεται, ώστε να προκύψει μια εκτίμηση της κίνησης και της περιστροφής του drone. 

Για τον συγχρονισμό των μηνυμάτων χρησιμοποιείται το ROS πακέτο Message Filters\footnote{\href{http://wiki.ros.org/message\_filters}{http://wiki.ros.org/message\_filters}} και πιο συγκεκριμένα το ApproximateTime Policy. Η μέθοδος αυτή χρησιμοποιεί έναν αλγόριθμο που προσαρμόζεται ανάλογα με τις χρονικές σημάνσεις των μηνυμάτων που δέχεται. Για κάθε συνδυασμό μηνυμάτων που λαμβάνονται γίνονται οι υπολογισμοί που φαίνονται στον \autoref{alg:odometry_calculator}.

\begin{algorithm}[!ht]
 \caption{Αλγόριθμος υπολογισμού κίνησης και προσανατολισμού}
 \label{alg:odometry_calculator}
 \begin{algorithmic}[1]
    \Function{calculateOdometry}{height, imu, velocity}
        \State $dt \gets time.now - time.previous$
        \State $yaw \gets imu.yaw$
        \State $msg \gets NULL$ \Comment{Contains position and orientation that will be published}
        \State $msg.position.x = position.x + (cos(yaw) \cdot velocity.x - sin(yaw) \cdot velocity.y) * dt$
        \State $msg.position.y = position.y + (sin(yaw) \cdot velocity.x + cos(yaw) \cdot velocity.y) * dt$
        \State $msg.position.z = height$
        \State $msg.orientation = imu.orientation$ 
        \State $publish(msg)$
    \EndFunction 
    \end{algorithmic}
\end{algorithm}

Αρχικά, υπολογίζεται το χρονικό διάστημα $dt$ που μεσολάβησε ανάμεσα στις διαδοχικές κλήσεις της συνάρτησης. Από το μήνυμα του IMU υπολογίζεται η τιμή του $yaw$ στο drone. Δεδομένης αυτής της τιμής, περιστρέφουμε το διάνυσμα της ταχύτητας $velocity$, ώστε να μετασχηματιστεί από το πλαίσιο του ρομπότ στο πλαίσιο του κόσμου που βρίσκεται, όπως φαίνεται παρακάτω:
\begin{equation*}
     linear\_velocity_{transformed} = 
     \left[ {\begin{array}{ccc}
        cos\theta & sin\theta & 0 \\
        -sin\theta & cos\theta & 0 \\
        0 & 0 & 1
    \end{array} } \right]
    \left[ {\begin{array}{c}
        linear\_velocity_{x} \\
        linear\_velocity_{y} \\
        linear\_velocity_{z}
    \end{array} } \right]
\end{equation*}

Στη συνέχεια, η ποσότητα αυτή ολοκληρώνεται στο χρόνο που μεσολάβησε και προστίθεται στην προηγούμενη τιμή της θέσης. Το ύψος λαμβάνεται απευθείας από την τιμή $height$ του αισθητήρα ύψους. Τέλος, ο προσανατολισμός του drone δίνεται άμεσα από τον αισθητήρα IMU. Η σύνθεση αυτών αποστέλλεται στο κατάλληλο ROS topic, $/amcl\_pose$, και αυτή η διαδικασία επαναλαμβάνεται συνεχώς.

Όσον αφορά το μοντέλο μέτρησης, αυτό χρησιμοποιεί τις μετρήσεις που προέρχονται από το laser, ώστε να εκτιμήσει το νέο βάρος κάθε σωματιδίου, ανάλογα με την θέση του. Αρχικά, οι μετρήσεις του αισθητήρα laser έρχονται σε 8 διαφορετικά ROS topic, τύπου sensor\_msgs/Range. Με την χρήση μιας τροποποιημένης έκδοσης του πακέτου teraranger\_array\_converter\footnote{\href{https://github.com/kosmastsk/teraranger\_array\_converter}{https://github.com/kosmastsk/teraranger\_array\_converter}} τα μηνύματα αυτά συγχωνεύονται σε ένα topic και στη συνέχεια μετατρέπονται σε μορφή sensor\_msgs/LaserScan. Η μορφή αυτή αποτελεί τον πιο συνηθισμένο τύπο για χειρισμό δεδομένων από αισθητήρα laser και περιέχει χρήσιμες πληροφορίες σχετικά με την ελάχιστη γωνία κάλυψης, τη γωνία μεταξύ διαδοχικών μετρήσεων και το εύρος του laser. Συνεπώς, ανακατασκευάζουμε τα σημεία στον τρισδιάστατο χώρο και μετατρέπουμε το μήνυμα σε μορφή PointCloud, της βιβλιοθήκης PCL\footnote{\href{http://pointclouds.org/}{http://pointclouds.org/}}. Το βήμα αυτό είναι χρήσιμο για την περίπτωση όπου το laser περιέχει μεγάλο αριθμό ακτινών και η επεξεργασία τους θα οδηγήσει σε αργοπορημένη απόκριση, δημιουργώντας την ανάγκη για υποδειγματοληψία. Στην συγκεκριμένη περίπτωση, δεν πραγματοποιείται καμία επεξεργασία, παρά μόνο παρέχεται μία λύση που καλύπτει κάθε αισθητήρα απόστασης, ανεξαρτήτως χαρακτηριστικών. Το τελευταίο βήμα της προ-επεξεργασίας είναι ο μετασχηματισμός των δεδομένων ως προς το κέντρο του κάθε σωματιδίου. Χρησιμοποιείται ο μετασχηματισμός μεταξύ του ρομπότ και του αισθητήρα, ο οποίος παρέχεται μέσω της κλάσης \emph{tf2\_ros::Buffer} της βιβλιοθήκης TF του ROS. Αυτός συνδυάζεται με την θέση του κάθε σωματιδίου και προκύπτει ο τελικός μετασχηματισμός, ώστε τα δεδομένα να βρίσκονται στην σωστή θέση.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.8\textwidth]{./images/chapter5/pf.png}
        \caption{Διαδικασία ενός φίλτρου σωματιδίων} 
    \label{fig:pf}
\end{figure}

Εφόσον η προ-επεξεργασία έχει ολοκληρωθεί το φίλτρο ξεκινάει τη λειτουργία του, η οποία σχηματικά περιγράφεται στο \autoref{fig:pf}. Ο αριθμός των σωματιδίων ορίζεται ως παράμετρος στο σύστημα και είναι μια τιμή που επιτρέπει την ισορροπία ανάμεσα στην ακρίβεια των υπολογισμών και των υπολογιστικών πόρων που είναι διαθέσιμοι. Αρχικά, εφαρμόζεται δειγματοληψία των σωματιδίων ανάλογα με το βάρος τους. Στη συνέχεια, μετατοπίζουμε την θέση του κάθε σωματιδίου, σύμφωνα με το κινηματικό μοντέλο που έχει δημιουργηθεί. Μέσω της βιβλιοθήκης TF το σύστημα αναζητά την τρέχουσα θέση του ρομπότ στον κόσμο, την οποία μετασχηματίζει σε ένα διαφορετικό σύστημα συντεταγμένων, με χρήση της μεθόδου $transform(\cdot)$ της κλάσης \emph{tf2\_ros::Buffer}. Δίνοντας ως όρισμα το μοναδιαίο διάνυσμα του ρομπότ, επιστρέφει τη νέα θέση στο σύστημα συντεταγμένων που μεταβάλλεται με την μεταβολή της οδομετρίας. Έχοντας πλέον τις δύο αυτές θέσεις, μπορούμε να υπολογίσουμε την διαφορά τους και συνεπώς την κίνηση που έχει κάνει το ρομπότ. Ο μετασχηματισμός αυτός εφαρμόζεται σε όλα τα σωματίδια, ώστε να μετατοπιστούν στις νέες τους θέσεις.

Τελικό στάδιο του φίλτρου είναι η αξιολόγηση των μετρήσεων που έχουν ληφθεί από τον αισθητήρα απόστασης με βάση το μοντέλο μέτρησης. Το κάθε σωματίδιο αξιολογείται αναθέτοντας σε αυτό, ανάλογα με το μοντέλο που έχει καθοριστεί ένα βάρος. Το βάρος αυτό προσεγγίζει την πιθανότητα το συγκεκριμένο σωματίδιο να είναι η ορθή κατάσταση, δηλαδή η μέτρηση που έχει ληφθεί να αντιστοιχεί σε αυτήν που θα ανίχνευε αν όντως βρισκόταν σε αυτήν την κατάσταση. Εκτός από μία εκτίμηση θέσης από κάθε σωματίδιο, το σύστημα εξάγει και μια συνολική εκτίμηση για την θέση. Αυτή προκύπτει από ένα ποσοστό των καλύτερων σωματιδίων, το οποίο μπορεί να επιλεγεί από τον χρήστη. Δεν υπάρχει κάποια συγκεκριμένη τιμή του ποσοστού που να εγγυάται καλύτερα αποτελέσματα, καθώς αυτό μπορεί να διαφέρει ανάλογα με τις ιδιαιτερότητες κάθε περίπτωσης.

Ένα βασικό πρόβλημα των αισθητήρων είναι η ύπαρξη θορύβου, κάτι που συχνά δεν λαμβάνεται υπόψη στους υπολογισμούς. Στην συγκεκριμένη περίπτωση όμως, η έλλειψη ακρίβειας που παρουσιάζουν τα μοντέλα των αισθητήρων ενσωματώνεται στην μοντελοποίηση της διαδικασίας μέτρησης ως πυκνότητας μιας υπό συνθήκη πιθανότητας, αντί μιας αιτιοκρατικής συνάρτησης. Το μοντέλο μέτρησης που χρησιμοποιήθηκε περιγράφεται στο \cite{thrun2005} και περιλαμβάνει τέσσερις τύπους σφαλμάτων μέτρησης, που είναι όλοι βασικοί για την σωστή λειτουργία του μοντέλου: το λιγοστό θόρυβο μέτρησης, τα σφάλματα που οφείλονται σε μη αναμενόμενα αντικείμενα, τα σφάλματα που οφείλονται σε αποτυχίες εντοπισμού αντικειμένων και τον τυχαίο ανεξήγητο θόρυβο. Η πραγματική απόσταση $z_t^k$ που βρίσκεται η κατάσταση μπορεί να υπολογιστεί εύκολα, μέσω των συναρτήσεων της βιβλιοθήκης OctoMap που παρέχουν αυτήν την δυνατότητα του Raytracing. Σε κάθε διάγραμμα στο \autoref{fig:measurement_model} ο οριζόντιος άξονας αντιστοιχεί στη μέτρηση $z_t^k$ και ο κατακόρυφος στην πιθανότητα. 

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.8\textwidth]{./images/chapter5/measurement_model.png}
    \caption{Τα στοιχεία του μοντέλου για έναν αισθητήρα μέτρησης απόστασης}
    \label{fig:measurement_model}
\end{figure} 

Επομένως, το ζητούμενο μοντέλο $p(z_t | x_t, m)$ είναι ένα μείγμα των παρακάτω τεσσάρων πυκνοτήτων, καθεμία από τις οποίες αντιστοιχεί σε συγκεκριμένο τύπο σφάλματος.

\emph{Σωστή απόσταση με τοπικό θόρυβο μέτρησης:} Ακόμα και αν ο αισθητήρας μετράει σωστά την απόσταση από το πλησιέστερο αντικείμενο, η τιμή που επιστρέφει μπορεί να επηρεαστεί από κάποιο σφάλμα. Το τελευταίο οφείλεται στην περιορισμένη ανάλυση των αισθητήρων μέτρησης απόστασης, στις ατμοσφαιρικές επιδράσεις στο σήμα της μέτρησης κ.ο.κ. Αυτός ο θόρυβος μέτρησης μοντελοποιείται συνήθως με μια μικρού πλάτους κατανομή Gauss, όπως φαίνεται στο \autoref{fig:measurement_model}(a). Επομένως, η πιθανότητα μέτρησης δίνεται από τον παρακάτω τύπο:
\begin{equation*}
 p_{hit}(z_t^k | x_t, m) =
  \begin{cases}
    \eta N_(z_t^k, z_t^{k*}, \sigma_{hit}^2) & \quad \text{if } 0 < z_t^k < z_{max}\\
    0  & \quad \text{else}
  \end{cases}
\end{equation*}

\begin{equation*}
    N_(z_t^k, z_t^{k*}, \sigma_{hit}^2) = \frac{1}{\sqrt{2\pi\sigma_{hit}^2}} e^{-\frac{1}{2} \frac{(z_t^k - z_t^{k*})^2}{\sigma_{hit}^2} }
\end{equation*}

\emph{Μη αναμενόμενα αντικείμενα:} Τα περιβάλλοντα των κινητών ρομπότ είναι δυναμικά, ενώ οι χάρτες στατικοί. Αυτό έχει ως αποτέλεσμα τα αντικείμενα που δεν περιέχονται στο χάρτη να αποτελούν την αιτία για την οποία οι αισθητήρες μέτρησης απόστασης παράγουν αναπάντεχα μικρές αποστάσεις. Μια απλή μέθοδος για να αντιμετωπίσουμε τέτοιες καταστάσεις είναι να τις θεωρήσουμε ως θόρυβο. Σε τέτοιες περιπτώσεις η πιθανότητα των μετρήσεων απόστασης περιγράφεται από μια εκθετική κατανομή, όπως φαίνεται στο \autoref{fig:measurement_model}(b). Η παράμετρος $\lambda_{short}$ είναι μια εγγενής παράμετρος του μοντέλου μέτρησης. Η πιθανότητα $p_{short}(z_t^k | x_t, m)$ δίνεται από τον παρακάτω τύπο:
\begin{equation*}
 p_{short}(z_t^k | x_t, m) =
  \begin{cases}
    \eta \lambda_{short} e^{-\lambda_{short} z_t^k} & \quad \text{if } 0 < z_t^k < z_{max}\\
    0  & \quad \text{else}
  \end{cases}
\end{equation*}

\emph{Αποτυχίες:} Μερικές φορές τα εμπόδια δεν εντοπίζονται. Αυτό μπορεί να συμβεί σε αισθητήρες σόναρ εξαιτίας των κατευθυνόμενων ανακλάσεων ή στους αισθητήρες λέιζερ όταν ανιχνεύονται μαύρα αντικείμενα που απορροφούν το φως. Ένα ακόμη τυπικό παράδειγμα αποτυχίας είναι η μέτρηση μέγιστης απόστασης, ο αισθητήρας επιστρέφει την μέγιστη επιτρεπόμενη τιμή $z_{max}$. Η περίπτωση αυτή μοντελοποιείται με μια κατανομή σημειακής μάζας που είναι κεντραρισμένη στην τιμή $z_{max}$, όπως φαίνεται στο \autoref{fig:measurement_model}(c).
\begin{equation*}
 p_{max}(z_t^k | x_t, m) =
  \begin{cases}
    1 & \quad \text{if } z = z_{max}\\
    0  & \quad \text{else}
  \end{cases}
\end{equation*}

\emph{Τυχαίες μετρήσεις:}  Τέλος, οι αισθητήρες απόστασης παράγουν περιστασιακά εντελώς ανεξήγητες μετρήσεις. Για λόγους απλότητας μοντελοποιούμε αυτές τις μετρήσεις χρησιμοποιώντας μια ομοιόμορφη κατανομή που καλύπτει ολόκληρο το εύρος των μετρήσεων, όπως φαίνεται στο \autoref{fig:measurement_model}(d).
\begin{equation*}
 p_{rand}(z_t^k | x_t, m) =
  \begin{cases}
    \frac{1}{z_{max}} & \quad \text{if } 0 < z_t^k < z_{max}\\
    0  & \quad \text{else}
  \end{cases}
\end{equation*}

Οι συγκεκριμένες τέσσερις διαφορετικές κατανομές συνδυάζονται με τη χρήση ενός σταθμισμένου μέσου όρου, που ορίζεται από τις παραμέτρους $z_{hit}$, $z_{short}$, $z_{max}$ και $z_{rand}$ με το άθροισμα αυτών να ισούται με 1. Αυτό είναι εφικτό, καθώς θεωρούμε ότι οι μεμονωμένες μετρήσεις είναι υπό συνθήκη ανεξάρτητες.

\begin{algorithm}[!ht]
 \caption{Αλγόριθμος υπολογισμού πιθανότητας μιας σάρωσης απόστασης}
 \label{alg:range_model}
    \begin{algorithmic}[1]
        \State $q \gets 1$
        \For{k=1 to K} 
            \State {Υπολογισμός της $z_t^{k*}$ για την μέτρηση $z_t^k$ με ρίψη ακτίνων}
            \State $p \gets z_{hit} \cdot p_{hit}(z_t^k | x_t, m) + z_{short} \cdot p_{short}(z_t^k | x_t, m) + z_{max} \cdot  p_{max}(z_t^k | x_t, m) + z_{rand} \cdot p_{rand}(z_t^k | x_t, m)$
            \State $q \gets q \cdot p$
        \EndFor
        \State \Return $q$
    \end{algorithmic}
\end{algorithm}

Ο αριθμός των σωματιδίων παραμένει σταθερός σε όλη τη διάρκεια της εκτέλεσης του φίλτρου, με αποτέλεσμα μετά από κάποια βήματα το βάρος ορισμένων σωματιδίων να γίνεται πολύ μικρό και τα σωματίδια αυτά να μην έχουν καμία επίδραση στο φίλτρο. Για το λόγο αυτό, εφαρμόζεται μια διαδικασία, γνωστή ως \emph{Αναδειγματοληψία}, κάθε φορά που η διακύμανση των βαρών των σωματιδίων είναι μικρότερη από το μισό του αριθμού των συνολικών σωματιδίων. Η τιμή αυτή λέγεται $N_{eff}$ και περιγράφει το κατά πόσο όμοια είναι κατανεμημένα τα βάρη. Το βήμα της αναδειγματοληψίας είναι μια πιθανοτική υλοποίηση της ιδέας του Δαρβίνου για την επικράτηση του ισχυρότερου: επανασυγκεντρώνει το σύνολο των σωματιδίων σε περιοχές του χώρου καταστάσεων με μεγάλη εκ των υστέρων πιθανότητα. Με αυτόν τον τρόπο, εστιάζει τους υπολογιστικούς πόρους που χρησιμοποιούνται από τον αλγόριθμο του φίλτρου στις περιοχές του χώρου καταστάσεων που έχουν τη μεγαλύτερη σημασία.

\begin{algorithm}[!ht]
 \caption{Αναδειγματοληψία χαμηλής διακύμανσης}
 \label{alg:resampling}
    \begin{algorithmic}[1]
        \State $new\_particles \gets 0$
        \State $r \gets rand(0;M^{-1})$
        \State $c \gets w_t^{[1]}$
        \State $i \gets 1$
        \For{m=1 to M}
            \State $U \gets r + (m-1) \cdot M^{-1}$
            \While{U > c}
                \State $i \gets i + 1$
                \State $c = c + w_t^{[1]}$
            \EndWhile
            \State $new\_particles \gets new\_particles + w_t^{[i]}$
        \EndFor
        \State \Return $new\_particles$
    \end{algorithmic}
\end{algorithm}

Η στρατηγική που χρησιμοποιείται για την αναδειγματοληψία είναι αυτή της χαμηλής διακύμανσης και φαίνεται στον \autoref{alg:resampling}. Η μέθοδος αυτή, αντί να επιλέγει δείγματα ανεξάρτητα το ένα από το άλλο στη διαδικασία της αναδειγματοληψίας ακολουθεί μια στοχαστική διαδικασία. Υπολογίζεται ένας τυχαίος αριθμός και τα δείγματα επιλέγονται με βάση αυτόν, με πιθανότητα όμως που παραμένει ανάλογη του συντελεστή στάθμισης του δείγματος. Αυτό επιτυγχάνεται επιλέγοντας τον αριθμό $r$ στο διάστημα $[0, M^{-1}]$, όπου $M$ ο αριθμός των σωματιδίων που πρόκειται να ληφθούν. Έπειτα, επιλέγονται σωματίδια προσθέτοντας συνεχώς την σταθερή ποσότητα $M^{-1}$ στον αριθμό $r$ και επιλέγοντας το σωματίδιο που αντιστοιχεί στον αριθμό που προκύπτει. Με τον τρόπο αυτό, καλύπτεται ο χώρος με πιο συστηματικό τρόπο, ενώ επιτυγχάνεται δειγματοληψία με πολυπλοκότητα $\mathcal{O}(M)$, κάτι που είναι πολύ σημαντικό για ρομποτικές εφαρμογές που απαιτούν υψηλή απόδοση σε περιορισμένο υλικό.